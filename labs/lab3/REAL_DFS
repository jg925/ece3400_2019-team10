#include <StackArray.h>
#include <Servo.h>

Servo left;
Servo right;

// servo pins
int right_pin = 6;
int left_pin = 5;

// line sensor pins
int LEFT_LINE_SENSOR = A5;
int RIGHT_LINE_SENSOR = A4;

// IR sensor pins
#define right_ir_sensor 2
#define left_ir_sensor 4
#define front_ir_sensor 7

// IR Robot Detect Pins
int left_robot_detect = A3;
int center_robot_detect = A2;
int right_robot_detect = A1;

int left_pi_arr[10];
int center_pi_arr[10];
int right_pi_arr[10];
int leftcount = 0;
int centercount = 0;
int rightcount = 0;
int robot_threshold = 75;
int count_threshold = 5;

// boundary between "white" and "black"
int line_threshold = 650;

// initialization of line sensor values
int left_sensor_value = 0;
int right_sensor_value = 0;

// initialization of IR sensor values
int right_detect;
int left_detect;
int front_detect;

// initialization of Stack path, dfs stuff

enum direction {
  north,
  east,
  south,
  west
};

struct node {
  byte pos;            // FIRST FOUR BITS ARE X, LAST FOUR BITS ARE Y
  direction dir;
};

struct box{
  byte visited;
  byte walls;
};

StackArray <byte> path;
box maze[100];
node current;

// initialize green "done LED" and push button "start button"
int DONE_LED = 12;
int START_BUTTON = 8;

// initialize "beginning" which waits for button press or 950 Hz signal and "ending" which goes HIGH when we finished traversing the maze
int beginning;
int ending;

void halt() {
  left.write(90);
  right.write(90);
}

void moveForward() {
  left.write(180);
  right.write(0);
}

void slightRight() {
  left.write(180);
  right.write(85);
}

void slightLeft() {
  left.write(95);
  right.write(0);
}

void rotateRight() {
  left.write(120);
  right.write(120);
}

void rotateLeft() {
  left.write(60);
  right.write(60);
}

void right90Turn() {
  rotateRight();
  delay(725);
}

void left90Turn() {
  rotateLeft();
  delay(725);
}

void right180Turn() {
  rotateRight();
  delay(1450);
}


int navigate() {
  left_sensor_value = analogRead(LEFT_LINE_SENSOR);
  right_sensor_value = analogRead(RIGHT_LINE_SENSOR);

  // if both sensors on white
  if (left_sensor_value < line_threshold && right_sensor_value < line_threshold) {
    moveForward();
    delay(500);
    return 1;
  }
  
  // left on white, right on black --> slight left adjust
  else if (left_sensor_value < line_threshold && right_sensor_value >= line_threshold) {
    // left detects white, right detects black
   // Serial.println("LEFT ON WHITE");
    while (left_sensor_value < line_threshold && right_sensor_value >= line_threshold) {
      slightLeft();
      left_sensor_value = analogRead(LEFT_LINE_SENSOR);
      right_sensor_value = analogRead(RIGHT_LINE_SENSOR);
    }    
  }
  
  // right on white, left on black --> slight right adjust
  else if (left_sensor_value >= line_threshold && right_sensor_value < line_threshold) {
    // left detects black, right detects white
    //Serial.println("RIGHT ON WHITE");
    while (right_sensor_value < line_threshold && left_sensor_value >= line_threshold ) {
      slightRight();
      left_sensor_value = analogRead(LEFT_LINE_SENSOR);
      right_sensor_value = analogRead(RIGHT_LINE_SENSOR);
    }
  }
  
  // both sensors detect black --> go straight
  else if (left_sensor_value >= line_threshold && right_sensor_value >= line_threshold) {
   // Serial.println("ALL BLACK");
    moveForward();
  }
  return 0;
}


void dfs( byte location ) { // NOTE: location must be an open location for us to go to.

  int go_on = 0;
  while ( go_on != 1 ) { // Want to navigate to next intersection at location
    go_on = navigate();
  }
  halt(); // Just so we don't go anywhere ;)
  
  current = { location, current.dir };
  path.push(location); // Add current location to the path
  maze[int(location)].visited = 1; // Mark location as visited

  right_detect = digitalRead(right_ir_sensor);  // 0 when detecting
  left_detect = digitalRead(left_ir_sensor);   // 0 when detecting
  front_detect = digitalRead(front_ir_sensor);  // 0 when detecting

  // Properly assign wall bits (same as old DFS)
  maze[int(location)].walls = maze[int(location)].walls << 1;
  if ( !(left_detect) ) {
    maze[int(location)].walls = maze[int(location)].walls + B001;
  }
  
  maze[int(location)].walls = maze[int(location)].walls << 1;
  if ( !(front_detect) ) {
    maze[int(location)].walls = maze[int(location)].walls + B001;
  }
  
  maze[int(location)].walls = maze[int(location)].walls << 1;
  if ( !(right_detect) ) {
    maze[int(location)].walls = maze[int(location)].walls + B001;
  }

  // determine locations in maze array (will be used to check what's been visited already)

  byte locfront;
  byte locleft;
  byte locright;
  
  if (current.dir == north) {
    locfront = byte( int(location) + 1);  // y+1
    locleft =  byte( int(location) - 16); // x-1
    locright = byte( int(location) + 16); // x+1
  } else if (current.dir == east) {
    locfront = byte( int(location) + 16); // x+1
    locleft =  byte( int(location) + 1);  // y+1;
    locright = byte( int(location) - 1);  // y-1;
  } else if (current.dir == south) {
    locfront = byte( int(location) - 1);  // y-1
    locleft =  byte( int(location) + 16); // x+1
    locright = byte( int(location) - 16); // x-1
  } else { // current.dir == west
    locfront = byte( int(location) - 16); // x-1
    locleft =  byte( int(location) - 1);  // y-1;
    locright = byte( int(location) + 1);  // y+1;
  }

  Serial.println(locleft, BIN);
  Serial.println(locright, BIN);
  Serial.println(locfront, BIN);
  Serial.println(left_detect);
  Serial.println(right_detect);
  Serial.println(front_detect);
  
  if ( front_detect && !(int(maze[int(locfront)].visited)) ) { // if there's no wall in front and the location above has not been visited
    Serial.println("FRONT");
    dfs(locfront);
  } 
  if ( left_detect && !(int(maze[int(locleft)].visited)) ) { // if there's no wall to left and the location to left has not been visited
    Serial.println("LEFT");
    left90Turn();
    current.dir = direction( (current.dir - 1) % 4 );
    dfs(locleft);
  } 
  if ( right_detect && !int((maze[int(locright)].visited)) ) { // if there's no wall to right and the location to right has not been visited
    Serial.println("RIGHT");
    right90Turn();
    current.dir = direction( (current.dir + 1) % 4 );
    dfs(locright);
  }

  path.pop();
  byte return_to = path.peek(); // find where we need to go back to
  direction face;
  
  if ( ( int(current.pos) >> 4 - int(return_to) >> 4 ) == 1) { // if current_x - return_to_x == 1, want to face west
    face = west;
    go_on = 0;
  }
  else if ( ( int(current.pos) >> 4 - int(return_to) >> 4 ) == -1 ) { // if current_x - return_to_x == -1, want to face east
    face = east;
    go_on = 0;
  }
  else if ( (((int(current.pos) >> 4) << 4) - ((int(return_to) >> 4) << 4)) == 1) { // if current_y - return_to_y == 1, want to face south
    face = south;
    go_on = 0;
  }
  else if ( (((int(current.pos) >> 4) << 4) - ((int(return_to) >> 4) << 4)) == -1) { // if current_y - return_to_y == 1, want to face north
    face = north;
    go_on = 0;
  }
  else { // We are done!!
    face = current.dir;
    go_on = 1;
  }
  

  while (current.dir != face) {
    right90Turn();
    current.dir = direction( ( int( current.dir ) + 1 ) % 4 );
  }

  while ( go_on != 1 ) { // Want to get to next intersection (but to the last place in the path)
    go_on = navigate();
  }
  current = { return_to, face };
  halt(); // Just so we don't go anywhere ;)
  
}

void setup() {
  // put your setup code here, to run once:
  pinMode(LEFT_LINE_SENSOR, INPUT);
  pinMode(RIGHT_LINE_SENSOR, INPUT);
  pinMode(left_ir_sensor, INPUT);
  pinMode(front_ir_sensor, INPUT);
  pinMode(right_ir_sensor, INPUT);
  pinMode(left_robot_detect, INPUT);
  pinMode(center_robot_detect, INPUT);
  pinMode(right_robot_detect, INPUT);
  pinMode(START_BUTTON, INPUT);
  pinMode(DONE_LED, OUTPUT);
  Serial.begin(9600);
  right.attach(right_pin);
  left.attach(left_pin);
  halt();
  digitalWrite(DONE_LED, LOW);
  delay(3000); // Wait 3 seconds for us to move our hands out of the way/adjust robot before starting
  beginning = 1;
  ending = 0;
  current = { B00000000, north };
  for (int i = 0; i < 100; i++) { 
    maze[i].walls = B00000111;  // initialize all walls to be 111
  }
}

void loop() {
  // put your main code here, to run repeatedly:  
  while (beginning) {
    if (digitalRead(START_BUTTON)) {
      beginning = 0;
      for (int i = 0; i < 2; i++) { // WARNING: PLEASE STEP A SAFE DISTANCE AWAY FROM THE ROBOT ;)
        digitalWrite(DONE_LED, HIGH);
        delay(500); 
        digitalWrite(DONE_LED, LOW);
        delay(500);
      }
    }
  }
  if (!(ending)) {
    path.push(current.pos);
    front_detect = digitalRead(front_ir_sensor);
    if (front_detect) {
      Serial.println("Begin DFS1");
      dfs( byte( int(current.pos) + 1 ) ); // bits are 76543210, this will increment bit 0 by 1 
      Serial.println("End DFS1");
    }
    right_detect = digitalRead(right_ir_sensor);
    if (right_detect) {
      Serial.println("Begin DFS2");
      dfs( byte( int(current.pos) + 16 ) ); // bits are 76543210, this will increment bit 4 by 1 
      Serial.println("End DFS2");
    }
    ending = 1;
  }
  digitalWrite(DONE_LED, HIGH);  
}
